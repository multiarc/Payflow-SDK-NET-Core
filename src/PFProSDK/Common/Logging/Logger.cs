#region "Copyright"

//PayPal Payflow Pro .NET SDK
//Copyright (C) 2014  PayPal, Inc.
//
//This file is part of the Payflow Pro .NET SDK
//
//The Payflow .NET SDK is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//any later version.
//
//The Payflow .NET SDK is is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with the Payflow .NET SDK.  If not, see <http://www.gnu.org/licenses/>.

#endregion

#region "Using"

using System;
using System.Collections;
using System.IO;
using PFProSDK.Common.Utility;

//using System.Configuration;
//using System.Xml;
//using System.Reflection;

#endregion

namespace PFProSDK.Common.Logging
{
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///     This is the main class which is used for Logging.It has a static constructor
    ///     which initializes the sortedlist containing all the error messages.
    ///     This class will primarily be used by the Context class.
    ///     The only method from this class which can be used outside the assembly is the log
    ///     method which takes in a string and severity level as parameters.
    /// </summary>
    /// <remarks>
    /// </remarks>
    /// -----------------------------------------------------------------------------
    public sealed class Logger
    {
        #region "Member variable"

        /// <summary>
        ///     This SortedList holds the Message code,Body and severity level of the messages
        ///     mentioned in the XML file.
        /// </summary>
        private SortedList _mMessages;

        /// <summary>
        ///     Holds the instance of this singleton class.
        /// </summary>
        private static Logger _mInstance;

        /// <summary>
        ///     Holds the errors generated by Logger class.
        /// </summary>
        private readonly ArrayList _mLoggerErrs = new ArrayList();

        /// <summary>
        ///     Holds log file name
        /// </summary>
        private string _mLogFileName;

        /// <summary>
        ///     Holds Log file size
        /// </summary>
        private long _mFileLength;

        /// <summary>
        ///     Holds log file
        /// </summary>
        private FileInfo _mFileInfo;

        /// <summary>
        ///     This StermWriter writes in to Log file
        /// </summary>
        private StreamWriter _mWriteToFile;

        /// <summary>
        ///     Holds Log file size Limit from Config file
        /// </summary>
        private long _mFileSize; // = PayflowConstants.LOGFILE_SIZE;

        /// <summary>
        ///     This flag indicates, if an error occurred because of the Logger class.
        /// </summary>
        private static bool _mErrInLogger;

        /// <summary>
        ///     Holds Log level info
        /// </summary>
        private int _mLogLevel;

        /// <summary>
        ///     Holds Log file size limit
        /// </summary>
        private string _mFileSizeLimit;

        /// <summary>
        ///     Hold COM information
        /// </summary>
        private readonly bool _mIsCom;

        private string _mStrLogLevel;
        public string MRequestId;

        #endregion

        #region "properties"

        #endregion

        #region "Private constructor"

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This private constructor reads the config file for the name of file which contains the
        ///     error messages.After getting the name it loads the static member "mMessages" with
        ///     the messages mentioned in the file.
        ///     Gets Log file name from Config file. If not available then assign default file name.
        ///     Gets Log file size from Config file. If not available then assign default file size.
        /// </summary>
        /// <returns>Nothing</returns>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        private Logger()
        {
            InitializeInstance();
        }

        private Logger(string loggingLevel, string logFileName, string maxLogLimit, bool isComWrapper)
        {
            _mStrLogLevel = loggingLevel;
            _mLogFileName = logFileName;
            _mFileSizeLimit = maxLogLimit;
            _mIsCom = isComWrapper;
            InitializeInstance();
        }

        private void InitializeInstance()
        {
            //FileSizeLimit="";
            var keyName = "";
            var isLogLevelKeyPresent = false;
            var isLogFilenameKeyPresent = false;
            var isLogFileSizeKeyPresent = false;

            /* Reads the config file to get the path of the file containing all the messages.
             * It will then load all the message from this file into the hashtable.
            */
            //Reads the XML message file and loads the messages into a error object.

            PopulateMessages();
            if (!_mIsCom)
                try
                {
                    _mStrLogLevel = PayflowUtility.AppSettings(PayflowConstants.ConfigLogLevel);
                }
                catch
                {
                    keyName = PayflowConstants.ConfigLogLevel;
                    _mLogLevel = PayflowConstants.LoggingOff;
                    isLogLevelKeyPresent = false;
                }

            if (_mStrLogLevel == null || _mStrLogLevel.Length == 0)
            {
                keyName = PayflowConstants.ConfigLogLevel;
                _mLogLevel = PayflowConstants.LoggingOff;
                isLogLevelKeyPresent = false;
            }
            else
            {
                switch (_mStrLogLevel.Trim().ToUpper())
                {
                    case "OFF":
                        _mLogLevel = PayflowConstants.LoggingOff;
                        break;
                    case "DEBUG":
                        _mLogLevel = PayflowConstants.SeverityDebug;
                        break;
                    case "INFO":
                        _mLogLevel = PayflowConstants.SeverityInfo;
                        break;
                    case "WARN":
                        _mLogLevel = PayflowConstants.SeverityWarn;
                        break;
                    case "ERROR":
                        _mLogLevel = PayflowConstants.SeverityError;
                        break;
                    case "FATAL":
                        _mLogLevel = PayflowConstants.SeverityFatal;
                        break;
                    default:
                        _mLogLevel = PayflowConstants.LoggingOff;
                        break;
                }
            }

            isLogLevelKeyPresent =
                _mLogLevel > PayflowConstants.LoggingOff && _mLogLevel <= PayflowConstants.SeverityFatal;


            // Do not need to do any further processing if Logging is set to OFF.
            if (_mLogLevel != PayflowConstants.LoggingOff)
            {
                if (!_mIsCom)
                    try
                    {
                        _mLogFileName = PayflowUtility.AppSettings(PayflowConstants.ConfigLogfileName);
                    }
                    catch
                    {
                        if (string.Empty.Equals(keyName))
                            keyName = PayflowConstants.ConfigLogfileName;
                        else
                            keyName = keyName + ", " + PayflowConstants.ConfigLogfileName;
                    }

                //				if (mLogFileName == null ||  mLogFileName.Length == 0)
                //				{
                //					mLogFileName = PayflowConstants.LOGFILE_NAME;
                //
                //				}

                // If no log file information found in .config file, create file name using relative path.
                if (_mLogFileName == null || _mLogFileName.Length == 0)
                    _mLogFileName = PayflowConstants.LogfileName;
                else
                    isLogFilenameKeyPresent = true;


                if (!_mIsCom)
                    try
                    {
                        _mFileSizeLimit = PayflowUtility.AppSettings(PayflowConstants.ConfigLogfileSize);
                    }
                    catch
                    {
                        //mFileSize = PayflowConstants.LOGFILE_SIZE; 
                        if (string.Empty.Equals(keyName))
                            keyName = PayflowConstants.ConfigLogfileSize;
                        else
                            keyName = keyName + ", " + PayflowConstants.ConfigLogfileSize;
                    }

                if (_mFileSizeLimit == null || _mFileSizeLimit.Length == 0)
                {
                    _mFileSize = PayflowConstants.LogfileSize;
                }
                else
                {
                    try
                    {
                        _mFileSize = int.Parse(_mFileSizeLimit);
                    }
                    catch
                    {
                        _mFileSize = PayflowConstants.LogfileSize;
                        if (string.Empty.Equals(keyName))
                            keyName = PayflowConstants.ConfigLogfileSize;
                        else
                            keyName = keyName + ", " + PayflowConstants.ConfigLogfileSize;
                    }

                    if (_mFileSize < 1)
                        _mFileSize = PayflowConstants.LogfileSize;
                    isLogFileSizeKeyPresent = true;
                }
            }

            if (!(isLogLevelKeyPresent && isLogFilenameKeyPresent && isLogFileSizeKeyPresent))
                if (!(isLogLevelKeyPresent == false && isLogFilenameKeyPresent == false &&
                      isLogFileSizeKeyPresent == false))
                {
                    ErrorObject error;
                    var respMessage = PayflowConstants.ParamResult
                                      + PayflowConstants.SeparatorNvp
                                      + (string) PayflowConstants.CommErrorCodes[PayflowConstants.EConfigError]
                                      + PayflowConstants.DelimiterNvp
                                      + PayflowConstants.ParamRespmsg
                                      + PayflowConstants.SeparatorNvp
                                      + (string) PayflowConstants.CommErrorMessages[PayflowConstants.EConfigError]
                                      + "Tags "
                                      + keyName
                                      + " are not present in the config file or config file is missing.";
                    if (isLogLevelKeyPresent == false)
                        error = new ErrorObject(PayflowConstants.SeverityError, "", respMessage);
                    else
                        error = new ErrorObject(PayflowConstants.SeverityWarn, "", respMessage);
                    _mLoggerErrs.Add(error);
                    //if(IsLogLevelKeyPresent )
                    //{
                    //	InitializeStream();
                    //}
                }
        }

        #endregion

        #region "Get Instance"

        /// <summary>
        ///     Holds the instance of this singleton class.
        /// </summary>
        public static Logger Instance
        {
            get
            {
                lock (typeof(Logger))
                {
                    if (_mInstance == null)
                        _mInstance = new Logger();
                    return _mInstance;
                }
            }
        }

        /// <summary>
        ///     Get the Errors generated from the Logger.
        /// </summary>
        public ArrayList GetLoggerErrs => _mLoggerErrs;

        #endregion

        #region "Methods"

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This is a internal method and takes in a errorobject as a parameter.This method
        ///     then calls another overloaded version for the method Log which takes in a
        ///     string to be logged and the severity level of the Error Object.
        /// </summary>
        /// <param name="message">ErrorObject</param>
        /// <return></return>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        internal void Log(ErrorObject message)
        {
            if (message != null) Log(message.ToString(), message.SeverityLevel);
        }


        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This is a internal method and takes in a arraylist of the errorobjects
        ///     as a parameter.The method goes through the array list for each errorobject
        ///     found makes a call to another overloaded version of the Log method which takes
        ///     in ErrorObject as a parameter.If there are some errors which have been generated by
        ///     the Logger class then those are logged instead of the passed messages.
        /// </summary>
        /// <param name="messages">ArrayList containing the error objects</param>
        /// <return></return>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        internal void Log(ArrayList messages) //ArrayList containing the error objects
        {
            var errCnt = 0;
            var errMaxCnt = 0;
            if (_mLoggerErrs.Count != 0) // This means no error was previously generated in this class
                messages = _mLoggerErrs;
            errMaxCnt = messages.Count;
            for (errCnt = 0; errCnt < errMaxCnt; errCnt++) Log((ErrorObject) messages[errCnt]);
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This method used to log the data in a file.Different type of severity level are logged here.
        ///     The levels that can be logged are decided by the configuration settings in the
        ///     Application config file.
        /// </summary>
        /// <param name="message">String value that needs to be logged</param>
        /// <param name="severityLvl">
        ///     Severity level of the message.This could be one of the following:
        ///     1 (Debug)
        ///     2 (Info)
        ///     3 (Warn)
        ///     4 (Error)
        ///     5 (Fatal)
        /// </param>
        /// <return></return>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        public void Log(string message, int severityLvl)
        {
            var strDebugLevel = string.Empty;
            var messageToLog = string.Empty;
            if (_mLogLevel != 0 && !_mErrInLogger)
                if (severityLvl >= _mLogLevel)
                    try
                    {
                        switch (severityLvl)
                        {
                            case PayflowConstants.SeverityDebug:
                                strDebugLevel = "DEBUG";
                                break;
                            case PayflowConstants.SeverityInfo:
                                strDebugLevel = "INFO";
                                break;
                            case PayflowConstants.SeverityWarn:
                                strDebugLevel = "WARN";
                                break;
                            case PayflowConstants.SeverityError:
                                strDebugLevel = "ERROR";
                                break;
                            case PayflowConstants.SeverityFatal:
                                strDebugLevel = "FATAL";
                                break;
                            default:
                                return;
                        }

                        InitializeStream();
                        //int nProcessID = System.Diagnostics.Process.GetCurrentProcess().Id;

                        messageToLog = "[" + DateTime.Now + ":" + GlobalClass.GlobalVar + ":[" + strDebugLevel + "]-" +
                                       message;
                        _mFileInfo.Refresh();
                        _mFileLength = _mFileInfo.Length + messageToLog.Length + 1;
                        _mWriteToFile.WriteLine(messageToLog);

                        if (_mFileLength >= _mFileSize)
                            if (ArchivedLogFile())
                                _mFileLength = 0;
                    }
                    catch (Exception ex)
                    {
                        var stackTrace = PayflowConstants.EmptyString;
                        PayflowUtility.InitStackTraceOn();
                        if (PayflowConstants.TraceOn.Equals(PayflowConstants.Trace)) stackTrace = ": " + ex.StackTrace;
                        var respMessage = PayflowConstants.ParamResult
                                          + PayflowConstants.SeparatorNvp
                                          + (string) PayflowConstants.CommErrorCodes[PayflowConstants.ELogError]
                                          + PayflowConstants.DelimiterNvp
                                          + PayflowConstants.ParamRespmsg
                                          + PayflowConstants.SeparatorNvp
                                          + (string) PayflowConstants.CommErrorMessages[PayflowConstants.ELogError]
                                          + PayflowConstants.MessageLogError
                                          + ex.Message
                                          + stackTrace;
                        var err = new ErrorObject(
                            PayflowConstants.SeverityWarn, "",
                            respMessage);
                        _mLoggerErrs.Add(err);
                        _mErrInLogger = true;
                    }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This is a internal method.This method contains implementation for rolling file functionality.
        /// </summary>
        /// <return></return>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        private bool ArchivedLogFile()
        {
            var archivedFile = false;
            FileInfo archivedLog = null;
            string tempFileName;
            _mWriteToFile.Close();
            try
            {
                var logfileName = _mFileInfo.FullName;
                var targetPosition = logfileName.LastIndexOf(_mFileInfo.Extension);
                for (var i = 1; !archivedFile; i++)
                {
                    tempFileName = logfileName.Insert(targetPosition, PayflowConstants.Underscore)
                        .Insert(targetPosition + 1, i.ToString());
                    archivedLog = new FileInfo(tempFileName);
                    if (!archivedLog.Exists)
                    {
                        _mFileInfo.CopyTo(tempFileName);
                        _mFileInfo.Delete();
                        archivedFile = true;
                    }
                }
            }
            catch
            {
                archivedFile = false;
            }

            _mWriteToFile = null;
            _mFileInfo = null;
            return archivedFile;
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///     This method populates each ErrorObject int the arraylist passed, with the
        ///     details from the SortedList held by the logger class.It populates the mLoggerErrs
        ///     in case the relevant message code is not found.
        /// </summary>
        /// <param name="errObj">ErrorObject</param>
        /// <returns>ErrorObject</returns>
        /// <remarks>
        /// </remarks>
        /// -----------------------------------------------------------------------------
        //Populate the error object with the details
        internal ArrayList PopulateErrorDetails(ArrayList errObj)
        {
            ErrorObject errMesg;
            ErrorObject retErrorObj = null;
            var retErrObjs = new ArrayList(0);
            int errCnt;
            int errMaxCnt;
            int sevLvlAssigned;
            string[] mesgParams;

            //Iterate through all the error objects in the array list 
            errMaxCnt = errObj.Count;
            for (errCnt = 0; errCnt < errMaxCnt; errCnt++)
            {
                if (((ErrorObject) errObj[errCnt]).MessageCode.Length != 0)
                {
                    errMesg = (ErrorObject) _mMessages[((ErrorObject) errObj[errCnt]).MessageCode];
                    if (((ErrorObject) errObj[errCnt]).SeverityLevel != 0)
                        sevLvlAssigned = ((ErrorObject) errObj[errCnt]).SeverityLevel;
                    else
                        sevLvlAssigned = errMesg.SeverityLevel;
                    mesgParams = new string[((ErrorObject) errObj[errCnt]).MessageParams.Count];
                    ((ErrorObject) errObj[errCnt]).MessageParams.CopyTo(mesgParams);
                    retErrorObj = new ErrorObject(sevLvlAssigned,
                        errMesg.MessageCode, errMesg.MessageBody,
                        mesgParams,
                        ((ErrorObject) errObj[errCnt]).ErrorStackTrace);
                }
                else //It is an exception.
                {
                    retErrorObj = (ErrorObject) errObj[errCnt];
                }

                retErrObjs.Add(retErrorObj);
            }

            return retErrObjs;
        }

        private void PopulateMessages()
        {
            _mMessages = new SortedList();
            ErrorObject err = null;
            err = new ErrorObject(PayflowConstants.SeverityInfo, PayflowConstants.MsgCommunicationError,
                "RESULT={0}&RESPMSG={1}");
            _mMessages.Add(PayflowConstants.MsgCommunicationError, err);
            err = null;
            err = new ErrorObject(PayflowConstants.SeverityInfo, PayflowConstants.MsgCommunicationErrorXmlpay,
                "<XMLPayResponse xmlns='http://www.paypal.com/XMLPay'><ResponseData><TransactionResults><TransactionResult><Result>{0}</Result><Message>{1}</Message></TransactionResult></TransactionResults></ResponseData></XMLPayResponse>");
            _mMessages.Add(PayflowConstants.MsgCommunicationErrorXmlpay, err);
            err = null;
            err = new ErrorObject(PayflowConstants.SeverityInfo, PayflowConstants.MsgCommunicationErrorNoResponseId,
                "RESULT={0}&RESPMSG={1}");
            _mMessages.Add(PayflowConstants.MsgCommunicationErrorNoResponseId, err);
            err = null;
            err = new ErrorObject(PayflowConstants.SeverityInfo,
                PayflowConstants.MsgCommunicationErrorXmlpayNoResponseId,
                "<XMLPayResponse xmlns='http://www.paypal.com/XMLPay'><ResponseData><TransactionResults><TransactionResult><Result>{0}</Result><Message>{1}</Message></TransactionResult></TransactionResults></ResponseData></XMLPayResponse>");
            _mMessages.Add(PayflowConstants.MsgCommunicationErrorXmlpayNoResponseId, err);
            err = null;
        }


        private void InitializeStream()
        {
            try
            {
                if (_mFileInfo == null || _mWriteToFile == null)
                {
                    _mFileInfo = new FileInfo(_mLogFileName);

                    if (_mFileInfo.Extension.Length == 0)
                    {
                        _mLogFileName = _mLogFileName + ".Log";
                        _mFileInfo = new FileInfo(_mLogFileName);
                    }

                    if (!Directory.Exists(_mFileInfo.DirectoryName))
                        Directory.CreateDirectory(_mFileInfo.DirectoryName);
                    _mWriteToFile = new StreamWriter(_mLogFileName, true)
                    {
                        AutoFlush = true
                    };
                }
            }
            catch (Exception ex)
            {
                var stackTrace = PayflowConstants.EmptyString;
                PayflowUtility.InitStackTraceOn();
                if (PayflowConstants.TraceOn.Equals(PayflowConstants.Trace)) stackTrace = ": " + ex.StackTrace;
                var respMessage = PayflowConstants.ParamResult
                                  + PayflowConstants.SeparatorNvp
                                  + (string) PayflowConstants.CommErrorCodes[PayflowConstants.ELogError]
                                  + PayflowConstants.DelimiterNvp
                                  + PayflowConstants.ParamRespmsg
                                  + PayflowConstants.SeparatorNvp
                                  + (string) PayflowConstants.CommErrorMessages[PayflowConstants.ELogError]
                                  + PayflowConstants.MessageLogError
                                  + " " + ex.Message
                                  + " " + stackTrace;
                var err = new ErrorObject(
                    PayflowConstants.SeverityError, "",
                    respMessage);
                _mLoggerErrs.Add(err);
                _mErrInLogger = true;
            }
        }

        internal static void SetInstance(string loggingLevel, string logFileName, string maxLogSize, bool isComWrapper)
        {
            if (_mInstance != null) _mInstance = null;
            _mInstance = new Logger(loggingLevel, logFileName, maxLogSize, isComWrapper);
        }

        #endregion
    } // END CLASS DEFINITION Logger
} // Payments.Common.Logging